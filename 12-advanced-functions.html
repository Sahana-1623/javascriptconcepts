<!DOCTYPE html>
<html>
  <head>
    <title>advanced function</title>
  </head>
  <body>
    <button onclick="" class="js-button">Click</button>
    <script>
      /*
      const buttonElement = document.querySelector('.js-button');
      
      const eventListener = () => {
        console.log('click');
      }

      buttonElement.addEventListener('click', eventListener);

      buttonElement.removeEventListener('click', eventListener);

      buttonElement.addEventListener('click', () => {
        console.log('click2');
      });
      */

      /*
      greeting()      //hoisting
      function greeting() {
        console.log('hello');
      }
      greeting();
      //shortcut for above is
      //var greeting = function() {
      //  console.log('hello');
      //}
      // but the default (like above) has the advantages like 
      //1. easier to read 
      //2. hoisting - which means we can call this function before we can create the code. dont have to worry about the order. but if we save function in variable it doesnt work.
      //***********************************************************************************

      //functions are values
      const num = 2;
      //const function1 = function greeting() {       here we dont need greetings
      //the function without a name is called anonymous function like below we dont have greetings for the function to work.
      const function1 = function() {
        console.log('hello2');
      };
      console.log(function1);
      console.log(typeof function1);
      function1();

      const object1 = {
        num: 2,
        fun: function() {
          console.log('hello3');
        }
      };
      object1.fun();

      //pass value to function
      function display(param) {
        console.log(param);
      }
      display(2);
      
      //pass function into anotherfunction
      function run(param) {
        param();
      }
      run(function() {
        console.log('hello4');
      }); // the function we are passing in is called callback funtion
      */

      /*
      setTimeout(function() {
        console.log('timeout');
        console.log('timeout2');
      }, 3000);     //asynchronous code wont wait for timeout to finish to do next line.
      console.log('next line')  //asynchronous code
      //asynchronous code doesnt block out the code for 3sec waiting for the timer to finish. it set timer in the background then do the next line of code.  so this allow the code to do other things while timer run e.g., like timer in real life
      //all the codes we written before are all synchronous code. And the code inside the settimeout i.e., the function inside the settimeout is also synchronous e,g line 58

      setInterval(function() {
        console.log('Interval');
      }, 3000);
      console.log('next line 2');
      */
      /*
      [
        'make dinner',
        'wash dishes',
        'watch youtube'
      //].forEach(function(value, index) {   (foreach need to use arrowfunction which is better to read)
      ].forEach((value, index) => {
        if (value === 'wash dishes') {
          return;
        }
        console.log(index);
        console.log(value);
      })
      //break is not easy to use in foreach. then its better to use a regular for loop

      const regularFunction = function(param, param2) {
        console.log('hello');
        return 5;
      }

      const arrowFunction = (param, param2) => {
        console.log('hello');
        return 5;
      };
      arrowFunction();

      const oneParam = param => {
        console.log(param + 1);
      };
      oneParam(2);
      //arrowFunction has one parameter brackets() are optional 

      const oneLine = () => 2 + 3;
      console.log(oneLine());
      //when arrow function has one line code, then can put it on same line without curly bracket{} and without return.
      
      const object2 = {
        method: () => {

        },
        //for objects use below (shorthand method) cz easy to read
        method() {

        }
      };
      */

      console.log([1,-3,5].filter((value, index) => {
        /*if (value >= 0) {
          return true;  //include in new array
        } else {
          return false; //not include in new array
        }*/
        //shortcut for above

        return value >= 0;
      }));

      //map transfrom an array into another array
      console.log([1,1,3].map((value, index) => {
        //return 10;
        //return value + 10;
        return value * 2;
      }));
      //shortcut for above code
      console.log([1,1,3].map(value => value * 2));

      //Closure - if a function has access to a value, it will always have access to that value. e.g., 12-todo-list.js
    
    </script>
  </body>
</html>